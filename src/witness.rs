use num_bigint::BigInt;
use std::io;

/// Parses a witness file as generated by witness calculators of Circom.
///
/// Taken mostly from: [`zkmopro/witnesscalc_adapter`](https://github.com/zkmopro/witnesscalc_adapter/blob/main/witnesscalc_adapter/src/lib.rs)
/// Note that we use `le` (little-endian) byte order for all values here.
///
///
/// TODO: use `BufReader` with `seek_relative` to avoid buffering the entire witness file at once?
pub fn parse_witness_to_elems<T>(
    buffer: &[u8],
    chunk_to_elem: impl Fn(&[u8]) -> T,
) -> io::Result<Vec<T>> {
    let mut pos = 0;

    // skip format bytes (4 bytes)
    // ensure that this says "wtns" in ASCII
    if &buffer[pos..pos + 4] != b"wtns" {
        return Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "Invalid witness file format.",
        ));
    }
    pos += 4;

    // read version (4 bytes)
    let _version = u32::from_le_bytes(buffer[pos..pos + 4].try_into().unwrap());
    // println!("version: {:?}", _version);
    pos += 4;

    // read number of sections (4 bytes)
    let n_sections = u32::from_le_bytes(buffer[pos..pos + 4].try_into().unwrap());
    // println!("n_sections: {:?}", n_sections);
    pos += 4;

    // number of 8 bit integers per field element
    let mut n8 = 0;

    // iterate through sections to find section_id = 2 (witness data)
    //
    // each section has:
    // - section id (4 bytes)
    // - section length (8 bytes)
    for _ in 0..n_sections {
        let section_id = u32::from_le_bytes(buffer[pos..pos + 4].try_into().unwrap());
        // println!("section_id: {:?}", section_id);
        pos += 4;

        let section_length = u64::from_le_bytes(buffer[pos..pos + 8].try_into().unwrap());
        // println!("section_length: {:?}", section_length);
        pos += 8;

        match section_id {
            // [section 1]
            // - `n8` number of 8 bit integers per field element (4 bytes / u32)
            // - the field `q` value (32 bytes)
            // - number of witness values (4 bytes / `u32`)
            1 => {
                n8 = u32::from_le_bytes(buffer[pos..pos + 4].try_into().unwrap());
                pos += 4;
                // println!("n8: {:?}", n8);
                let _q = BigInt::from_signed_bytes_le(&buffer[pos..pos + 32]);
                pos += 32;
                // println!("q: {:?}", q);
                let _n_witness_values =
                    u32::from_le_bytes(buffer[pos..pos + 4].try_into().unwrap());
                pos += 4;
                // println!("n_witness_values: {:?}", n_witness_values);
            }

            // [section 2]
            // - witness data (`n8` bytes per element, section_length bytes total)
            2 => {
                // read & convert witness bytes into field elements
                let bigints: Vec<T> = buffer[pos..pos + section_length as usize]
                    .chunks(usize::try_from(n8).unwrap())
                    .map(chunk_to_elem)
                    .collect();

                return Ok(bigints);
            }
            // skip any other section
            _ => {
                pos = pos + section_length as usize;
            }
        }
    }

    Err(io::Error::new(
        io::ErrorKind::InvalidData,
        "Witness section not found.",
    ))
}
